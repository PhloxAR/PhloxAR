# -*- coding: utf-8 -*-

from __future__ import division, print_function
from __future__ import absolute_import, unicode_literals

from PhloxAR.base import *
import scipy.signal as signal
import scipy.optimize as optimize
import numpy as npy
import copy, operator


class LineScan(list):
    """
    A line scan is an one dimensional signal pulled from the intensity
    of a series of a pixels in ang image. LineScan allows you to do a
    series of operations just like on an image class object. You can
    also treat the line scan as a python list object. A LineScan object
    is automatically generated by calling ImageClass.get_line_scan on an
    image. You can also roll your own by declaring a LineScan object
    and passing the constructor a 1xN list of values.
    """
    point_loc = None
    image = None

    def __init__(self, args, **kwargs):
        if isinstance(args, npy.ndarray):
            args = args.tolist()
        super(LineScan, self).__init__(args)

        self.image = None
        self.pt1 = None
        self.pt2 = None
        self.row = None
        self.col = None
        self.channel = -1

        for key in kwargs:
            if key in self.__dict__:
                self.__dict__[key] = kwargs[key]

        if self.point_loc is None:
            self.point_loc = zip(range(0, len(self)), range(0, len(self)))

    def _update(self, obj):
        """
        Update LineScan instance object.
        :param obj: LineScan instance.
        :return: None.
        """
        self.image = obj.image
        self.pt1 = obj.pt1
        self.pt2 = obj.pt2
        self.row = obj.row
        self.col = obj.col
        self.channel = obj.channel
        self.point_loc = obj.point_loc

    def __getitem__(self, key):
        """
        :param key: index or slice.
        :return: a LineScan sliced.
        """
        item = super(LineScan, self).__getitem__(key)
        if isinstance(key, slice):
            return LineScan(item)
        else:
            return item

    def __sub__(self, other):
        if len(self) == len(other):
            ret_val = LineScan(map(operator.sub, self, other))
        else:
            print("Size mismatch.")
            return None
        ret_val._update(self)
        return ret_val

    def __add__(self, other):
        if len(self) == len(other):
            ret_val = LineScan(map(operator.add, self, other))
        else:
            print("Size mismatch.")
            return None

        ret_val._update(self)
        return ret_val

    def __mul__(self, other):
        if len(self) == len(other):
            ret_val = LineScan(map(operator.mul, self, other))
        else:
            print("Size mismatch.")
            return None

        ret_val._update(self)
        return ret_val

    def __div__(self, other):
        if len(self) == len(other):
            try:
                ret_val = LineScan(map(operator.div, self, other))
            except ZeroDivisionError:
                print("Second LineScan contains zeros.")
                return None
        else:
            print("Size mismatch.")
            return None

        ret_val._update(self)

    def smooth(self, degree=3):
        """
        Perform a Gaussian simple smoothing operation on the signal.
        :param degree: degree of the fitting function. Higher degree means
                        more smoothing.
        :return: a smoothed LineScan object.
        Notes:
        Cribbed from
        http://www.swharden.com/blog/2008-11-17-linear-data-smoothing-in-python/
        """
        window = degree * 2 - 1
        weight = npy.array([1.0] * window)
        weight_gauss = []

        for i in range(window):
            i = i - degree + 1
            frac = i / float(window)
            gauss = 1 / npy.exp((4 * frac) ** 2)
            weight_gauss.append(gauss)

        weight = npy.array(weight_gauss) * weight
        smoothed = [0.0] * (len(self) - window)

        for i in range(len(smoothed)):
            smoothed[i] = sum(npy.array(self[i:i+window])*weight) / sum(weight)

        front = self[0:degree - 1]
        front += smoothed
        front += self[-1 * degree:]
        ret_val = LineScan(front, image=self.image, point_loc=self.point_loc,
                           pt1=self.pt1, pt2=self.pt2)
        ret_val._update(self)
        return ret_val

    def normalize(self):
        """
        Normalize the signal so the maximum value is scaled to one.
        :return: a normalized ScanLine object.
        """
        tmp = npy.array(self, dtype='float32')
        tmp /= npy.max(tmp)
        ret_val = LineScan(list(tmp[:]), image=self.image,
                           point_loc=self.point_loc, pt1=self.pt1, pt2=self.pt2)
        ret_val._update(self)
        return ret_val

    def scale(self, val_range=(0, 1)):
        """
        Scale the signal  so the max and min values are all scaled to the values
        in val_range. This is handy if you want to compare the shape of tow
        signals that are scaled to different ranges.
        :param val_range: a tuple that provides the range of output signal.
        :return: a scaled LineScan object.
        """
        tmp = npy.array(self, dtype='float32')
        vmax = npy.max(tmp)
        vmin = npy.min(tmp)
        a = npy.min(val_range)
        b = npy.max(val_range)
        tmp = (((b - a) / (vmax - vmin)) * (tmp - vmin)) + a
        ret_val = LineScan(list(tmp[:]), image=self.image,
                           point_loc=self.point_loc, pt1=self.pt1, pt2=self.pt2)
        ret_val._update(self)

        return ret_val

    def minima(self):
        """
        Global minima in the line scan.
        :return: a list of tuples of the format: (LineScanIndex, MinimaValue,
                  (image_position_x, image_position_y))
        """
        minvalue = npy.min(self)
        idxs = npy.where(npy.array(self) == minvalue)[0]
        minvalue = npy.ones((1, len(idxs))) * minvalue
        minvalue = minvalue[0]
        pts = npy.array(self.point_loc)
        pts = pts[idxs]
        pts = [(p[0], p[1]) for p in pts]
        return zip(idxs, minvalue, pts)

    def maxima(self):
        """
        Global maxima in the line scan.
        :return: a list of tuples of the format: (LineScanIndex, MaximaValue,
                  (image_position_x, image_position_y))
        """
        maxvalue = npy.max(self)
        idxs = npy.where(npy.array(self) == maxvalue)[0]
        maxvalue = npy.ones((1, len(idxs))) * maxvalue
        maxvalue = maxvalue[0]
        pts = npy.array(self.point_loc)
        pts = pts[idxs]
        pts = [(p[0], p[1]) for p in pts]

        return zip(idxs, maxvalue, pts)

    def derivative(self):
        """
        Finds the discrete derivative of the signal. The discrete derivative
        is simply the difference between each successive samples. A good use of
        this function is edge detection.
        :return: a LineScan object.
        """
        tmp = npy.array(self, dtype='float32')
        d = [0]
        d += list(tmp[1:] - tmp[0:-1])
        ret_val = LineScan(d, image=self, point_loc=self.point_loc,
                           pt1=self.pt1, pt2=self.pt2)
        ret_val._update(self)
        return ret_val

    def local_minima(self):
        """
        Local minima are defined as points that are less than their neighbors
        to the left and to the right.
        :return: a list of tuples of the format: (LineScanIndex, MaximaValue,
                  (image_position_x, image_position_y))
        """
        tmp = npy.array(self)
        idx = npy.r_[True, tmp[1:] < tmp[:-1]] & npy.r_[tmp[:-1] < tmp[1:], True]
        i = npy.where(idx is True)[0]
        values = tmp[i]
        pts = npy.array(self.point_loc)
        pts = pts[i]
        pts = [(p[0], p[1]) for p in pts]

        return zip(i, values, pts)

    def local_maxmima(self):
        """
        Local minima are defined as points that are less than their neighbors
        to the left and to the right.
        :return: a list of tuples of the format: (LineScanIndex, MaximaValue,
                  (image_position_x, image_position_y))
        """
        tmp = npy.array(self)
        idx = npy.r_[True, tmp[1:] > tmp[:-1]] & npy.r_[tmp[:-1] > tmp[1:], True]
        i = npy.where(idx is True)[0]
        values = tmp[i]
        pts = npy.array(self.point_loc)
        pts = pts[i]
        pts = [(p[0], p[1]) for p in pts]

        return zip(i, values, pts)

    def resample(self, n=100):
        """
        Re-sample the signal to fit into n samples. This method is handy
        if you would like to resize multiple signals so that they fit
        together nice. Note that using n < len(LineScan) can cause data loss.
        :param n: number of samples to reshape to.
        :return: a LineScan object of length n.
        """
        sig = signal.resample(self, n)
        pts = npy.array(self.point_loc)
        x = linspace(pts[0, 0], pts[-1, 0], n)
        y = linspace(pts[0, 1], pts[-1, 1], n)
        pts = zip(x, y)
        ret_val = LineScan(list(sig), image=self.image, point_loc=self.point_loc,
                           pt1=self.pt1, pt2=self.pt2)
        ret_val._update(self)

        return ret_val

    def fit2model(self, func, p0=None):
        """
        Fit the data to the provided model. This can be any
        arbitrary 2D signal.
        :param func: a function of the form func(x_values, p0, p1, ... pn)
                      where p is parameter for the model.
        :param p0: a list of the initial guess for the model parameters.
        :return: a LineScan object where the fitted model data replaces
                  the actual data.
        """
        yvals = npy.array(self, dtype='float32')
        xvals = range(0, len(yvals), 1)
        popt, pcov = optimize.curve_fit(func, xvals, yvals, p0=p0)
        yvals = func(xvals, *popt)
        ret_val = LineScan(list(yvals), image=self.image,
                           point_loc=self.point_loc, pt1=self.pt1, pt2=self.pt2)
        ret_val._update(self)
        return ret_val

    def get_model_params(self, func, p0=None):
        """
        Fit a model to the data and then return.
        :param func: a function of the form func(x_values, p0, p1, ... pn)
                      where p is parameter for the model.
        :param p0: a list of the initial guess for the model parameters.
        :return: The model parameters as a list.
        """
        yvals = npy.array(self, dtype='float32')
        xvals = range(0, len(yvals), 1)
        popt, pcov = optimize.curve_fit(func, xvals, yvals, p0=p0)

        return popt

    def convolve(self, kernel):
        """
        Convolve the line scan with a one dimensional kernel stored as
        a list. Allows you to create an arbitrary filter for the signal.
        :param kernel: an Nx1 list or npy.array that defines the kernel.
        :return: a LineScan feature with the kernel applied. We crop
                  the fiddly bits at the end and the begging of the kernel
                  so everything lines up nicely.
        """
        out = npy.convolve(self, npy.array(kernel, dtype='float32'), 'same')
        ret_val = LineScan(out, image=self.image, point_loc=self.point_loc,
                           pt1=self.pt1, pt2=self.pt2, channel=self.channel)
        return ret_val

    def fft(self):
        """
        Perform a Fast Fourier Transform on the line scan and return
        the FFT output and the frequency of each value.
        :return: the FFT as a numpy array of irrational numbers and a one
                  dimensional list of frequency values.
        """
        sig = npy.array(self, dtype='float32')
        fft = npy.fft.fft(sig)
        freq = npy.fft.fftfreq(len(sig))

        return fft, freq

    def ifft(self, fft):
        """
        Perform a inverse Fast Fourier Transform on the provided irrationally
        valued signal and return the results as a LineScan.
        :param fft: a one dimensional numpy array of irrational values upon
                     which we will perform the IFFT.
        :return: a LineScan object of the reconstructed singal.
        """
        sig = npy.fft.ifft(fft)
        ret_val = LineScan(sig.real)
        ret_val.image = self.image
        ret_val.point_loc = self.point_loc
        return ret_val

    def empty_lut(self, val=-1):
        """
        Create an empty look up table(LUT)
        :param val: If default value is what the lut is initially filled with
        if val == 0
            the array is all zeros.
        if val > 0
            the array is set to default value. Clipped to 255.
        if val < 0
            the array is set to the range [0,255]
        if val is a tuple of two values:
            we set stretch the range of 0 to 255 to match the range provided.
        :return: a LUT.
        """
        lut = None
        if isinstance(val, list) or isinstance(val, tuple):
            start = npy.clip(val[0], 0, 255)
