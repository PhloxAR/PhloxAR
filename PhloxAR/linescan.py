# -*- coding: utf-8 -*-

from __future__ import division, print_function
from __future__ import absolute_import, unicode_literals

from PhloxAR.base import *
import scipy.signal as signal
import scipy.optimize as optimize
import numpy as npy
import copy, operator


class LineScan(list):
    """
    A line scan is an one dimensional signal pulled from the intensity
    of a series of a pixels in ang image. LineScan allows you to do a
    series of operations just like on an image class object. You can
    also treat the line scan as a python list object. A LineScan object
    is automatically generated by calling ImageClass.get_line_scan on an
    image. You can also roll your own by declaring a LineScan object
    and passing the constructor a 1xN list of values.
    """
    point_loc = None
    image = None

    def __init__(self, args, **kwargs):
        if isinstance(args, npy.ndarray):
            args = args.tolist()
        super(LineScan, self).__init__(args)

        self.image = None
        self.pt1 = None
        self.pt2 = None
        self.row = None
        self.col = None
        self.channel = -1

        for key in kwargs:
            if key in self.__dict__:
                self.__dict__[key] = kwargs[key]

        if self.point_loc is None:
            self.point_loc = zip(range(0, len(self)), range(0, len(self)))

    def _update(self, obj):
        """
        Update LineScan instance object.
        :param obj: LineScan instance.
        :return: None.
        """
        self.image = obj.image
        self.pt1 = obj.pt1
        self.pt2 = obj.pt2
        self.row = obj.row
        self.col = obj.col
        self.channel = obj.channel
        self.point_loc = obj.point_loc

    def __getitem__(self, key):
        """
        :param key: index or slice.
        :return: a LineScan sliced.
        """
        item = super(LineScan, self).__getitem__(key)
        if isinstance(key, slice):
            return LineScan(item)
        else:
            return item

    def __sub__(self, other):
        if len(self) == len(other):
            ret_val = LineScan(map(operator.sub, self, other))
        else:
            print("Size mismatch.")
            return None
        ret_val._update(self)
        return ret_val

    def __add__(self, other):
        if len(self) == len(other):
            ret_val = LineScan(map(operator.add, self, other))
        else:
            print("Size mismatch.")
            return None

        ret_val._update(self)
        return ret_val

    def __mul__(self, other):
        if len(self) == len(other):
            ret_val = LineScan(map(operator.mul, self, other))
        else:
            print("Size mismatch.")
            return None

        ret_val._update(self)
        return ret_val

    def __div__(self, other):
        if len(self) == len(other):
            try:
                ret_val = LineScan(map(operator.div, self, other))
            except ZeroDivisionError:
                print("Second LineScan contains zeros.")
                return None
        else:
            print("Size mismatch.")
            return None

        ret_val._update(self)

    def smooth(self, degree=3):
        """
        Perform a Gaussian simple smoothing operation on the signal.
        :param degree: degree of the fitting function. Higher degree means
                        more smoothing.
        :return: a smoothed LineScan object.
        Notes:
        Cribbed from
        http://www.swharden.com/blog/2008-11-17-linear-data-smoothing-in-python/
        """
        window = degree * 2 - 1
        weight = npy.array([1.0] * window)
        weight_gauss = []

        for i in range(window):
            i = i - degree + 1
            frac = i / float(window)
            gauss = 1 / npy.exp((4 * frac) ** 2)
            weight_gauss.append(gauss)

        weight = npy.array(weight_gauss) * weight
        smoothed = [0.0] * (len(self) - window)

        for i in range(len(smoothed)):
            smoothed[i] = sum(npy.array(self[i:i+window]) * weight) / sum(weight)

        front = self[0:degree-1]
        front += smoothed
        front += self[-1*degree:]
        ret_val = LineScan(front, image=self.image, point_loc=self.point_loc,
                           pt1=self.pt1, pt2=self.pt2,)
        ret_val._update(self)
        return ret_val

    def normalize(self):
        """
        Normalize the signal so the maximum value is scaled to one.
        :return: a normalized ScanLine object.
        """
        tmp = npy.array(self, dtype='float32')
        tmp /= npy.max(tmp)
        ret_val = LineScan(list(tmp[:]), image=self.image,
                           point_loc=self.point_loc, pt1=self.pt1, pt2=self.pt2)
        ret_val._update(self)
        return ret_val

    def scale(self, val_range=(0,1)):
        """
        Scale the signal  so the max and min values are all scaled to the values
        in val_range. This is handy if you want to compare the shape of tow
        signals that are scaled to different ranges.
        :param val_range: a tuple that provides the range of output signal.
        :return: a scaled LineScan object.
        """
        tmp = npy.array(self, dtype='float32')
        vmax = npy.max(tmp)
        vmin = npy.min(tmp)
        a = npy.min(val_range)
        b = npy.max(val_range)
        tmp = (((b-a) / (vmax-vmin)) * (tmp-vmin)) + a
        ret_val = LineScan(list(tmp[:]), image=self.image,
                           point_loc=self.point_loc, pt1=self.pt1, pt2=self.pt2)
        ret_val._update(self)

        return ret_val
